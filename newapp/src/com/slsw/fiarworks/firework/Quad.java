
package com.slsw.fiarworks.firework;


public class Quad
{
	public static final Vec3 worldx = new Vec3(1,0,0);
	public static final Vec3 worldz = new Vec3(0,0,1);
	Vec3 p1;
	Vec3 p2;
	Vec3 p3;
	Vec3 p4;
	// Spark generated by fireworks routine
	Quad(Spark s)
	{
		// size is half-width of the spark
		float size = 0.1f;
		// spark center pos in world coords
		Vec3 p_ = s.position;

		{
			// NON-ROTATED quad coordinates in XZ plane, Z being up.
			// Assumes points are set to p_ first!
			// IF THE BILLBOARDING DOESN'T WORK, SWITCH TO THIS FOR NOW. 
			p1 = new Vec3(p_);
			p2 = new Vec3(p_);
			p3 = new Vec3(p_);
			p4 = new Vec3(p_);
			// bottom-left
			p1.add(-size, 0.0f, -size);
			// bottom-right		
			p2.add(size, 0.0f, -size);
			// top-left
			p3.add(-size, 0.0f, size);
			// top-right		
			p4.add( size, 0.0f, size);
		}

		{
			// ROTATED billboard coordinates. These should face the origin.
			// Not tested as of 6AM on Dec 5.
			
			// the objy axis points out the back of the quad
			Vec3 objy = new Vec3(p_);
			objy.unitize();
			
			// objx is generally the horizontal axis of the quad
			Vec3 objx;
			// if the particle is almost directly above or below the viewer
			// then we need to do something different to avoid numerical problems
			if (objy.isAlmostVertical()) {
				objx = objy.cross(worldx);
				
				// should be the same but faster maybe?
				//objx = new Vec3(0, objy.z, -objy.y); 
			}
			// ordinary situation
			else {
				objx = objy.cross(worldz);
				
				// should be the same but faster maybe?
				//objx = new Vec3(objy.y, -objy.x, 0);
			}
			objx.unitize();
			
			// objz is generally the vertical axis of the quad
			Vec3 objz = objx.cross(objy);
			objz.unitize();
			
			// half width of quad in objx dimension
			Vec3 hobjx = new Vec3(objx);
			hobjx.mult(size);
			
			// half width of quad in objz dimension
			Vec3 hobjz = new Vec3(objz);
			hobjz.mult(size);

			// start with points centered on the spark
			p1 = new Vec3(p_);
			p2 = new Vec3(p_);
			p3 = new Vec3(p_);
			p4 = new Vec3(p_);
			// shift points into position based on calculated half-width vectors
			// bottom-left
			p1.sub(hobjx);
			p1.sub(hobjz);
			// bottom-right		
			p2.add(hobjx);
			p2.sub(hobjz);
			// top-left
			p3.sub(hobjx);
			p3.add(hobjz);
			// top-right		
			p4.add(hobjx);
			p4.add(hobjz);

		}



	}

	public void set_quad(float[] buffer, int offset)
	{
		set_vertex(buffer, offset + 0 , p1);
		set_vertex(buffer, offset + 3 , p3);
		set_vertex(buffer, offset + 6, p2);
		set_vertex(buffer, offset + 9, p4);
		set_vertex(buffer, offset + 12, p3);
		set_vertex(buffer, offset + 15, p2);
	}

	private void set_vertex(float[] buffer, int offset, Vec3 p)
	{
		buffer[offset + 0] = p.x;
		buffer[offset + 1] = p.y;
		buffer[offset + 2] = p.z;
	}
}
